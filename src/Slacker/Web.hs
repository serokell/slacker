module Slacker.Web
  ( MessageContent(..)
  , blocks_
  , blocks
  , blocksJSON
  , text
  -- Response URL
  , MessagePayload(..)
  , respondMessage
  , response
  , ephemeral
  -- chat.postMessage
  , PostMessagePayload(..)
  , postMessage
  , toChannel
  , toThread
  , makeSlackPostJSON
  , makeSlackPostJSONNoBody
  ) where

import           Control.Lens hiding ((??))
import           Control.Monad (void)
import           Control.Monad.IO.Unlift (MonadIO, liftIO)
import qualified Data.Aeson as Aeson
import qualified Data.Aeson.Types as Aeson
import           Data.Aeson.Lens
import           Data.List.NonEmpty (NonEmpty(..))
import           Data.Maybe (catMaybes)
import           Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import           GHC.Generics (Generic)
import qualified Network.HTTP.Client as HTTP
import qualified Network.HTTP.Simple as HTTP
import           UnliftIO.Exception

import           Slacker.Blocks (Block(..))
import           Slacker.Config (SlackConfig(..))

data MessagePayload
  = MessagePayload
  { mpEphemeral :: !Bool
  , mpContent   :: !MessageContent
  } deriving stock (Generic, Show, Eq, Ord)

instance Aeson.ToJSON MessagePayload where
  toJSON MessagePayload{..}
    = Aeson.object
    $ catMaybes
    [ if mpEphemeral
        then Just ("response_type" Aeson..= Aeson.String "ephemeral")
        else Nothing
    ] ++ messageContentFields mpContent

response :: MessageContent -> MessagePayload
response = MessagePayload False

ephemeral :: MessageContent -> MessagePayload
ephemeral = MessagePayload True

data PostMessagePayload
  = PostMessagePayload
  { pmpChannel  :: !Text
  , pmpThreadTs :: !(Maybe Text)
  , pmpContent  :: !MessageContent
  } deriving stock (Generic, Show, Eq, Ord)

instance Aeson.ToJSON PostMessagePayload where
  toJSON PostMessagePayload{..}
    = Aeson.object
    $ catMaybes
    [ Just $ "channel" Aeson..= pmpChannel
    , fmap ("thread_ts" Aeson..=) pmpThreadTs
    ] ++ messageContentFields pmpContent

toChannel :: Text -> MessageContent -> PostMessagePayload
toChannel cid = PostMessagePayload cid Nothing

toThread :: Text -> Text -> MessageContent -> PostMessagePayload
toThread cid ts = PostMessagePayload cid (Just ts)

data MessageContent
  = MessageBlocks !(Maybe Text) !(NonEmpty Block)
  | MessageText !Text
  | MessageBlocksJSON !Aeson.Value
-- ^ An escape hatch if you want to use something like `aesonQQ` to write
-- literal JSON, like that generated by the Block Kit Builder:
-- https://app.slack.com/block-kit-builder/
  deriving stock (Show, Eq, Ord)

messageContentFields :: MessageContent -> [Aeson.Pair]
messageContentFields mc =
  case mc of
    MessageBlocks mText neBlocks -> catMaybes
      [ Just $ "blocks" Aeson..= neBlocks
      , fmap ("text" Aeson..=) mText
      ]
    MessageText txt ->
      [ "text" Aeson..= txt ]
    MessageBlocksJSON val ->
      [ "blocks" Aeson..= val ]

blocks :: Text -> NonEmpty Block -> MessageContent
blocks txt = MessageBlocks (Just txt)

blocks_ :: NonEmpty Block -> MessageContent
blocks_ = MessageBlocks Nothing

blocksJSON :: Aeson.Value -> MessageContent
blocksJSON = MessageBlocksJSON

text :: Text -> MessageContent
text = MessageText

-- | Respond to a user using an action's response URL.
-- https://api.slack.com/interactivity/handling#message_responses
respondMessage
  :: MonadIO m
  => Text
  -- ^ Response URL from Slack.
  -> MessagePayload
  -> m ()
respondMessage url body = do
  req <- liftIO $ HTTP.parseRequest $ "POST " <> T.unpack url
  void . HTTP.httpLBS . HTTP.setRequestBodyJSON body $ req

-- | Use the `chat.postMessage` method to send a message to a particular channel.
postMessage
  :: MonadIO m
  => SlackConfig
  -> PostMessagePayload
  -> m ()
postMessage cfg payload =
  void $
    makeSlackPostJSON
      (slackApiToken cfg)
      "chat.postMessage"
      payload

makeSlackPostJSON
  :: (MonadIO m, Aeson.ToJSON val)
  => Text
  -> Text
  -> val
  -> m Aeson.Value
makeSlackPostJSON token method body =
  makeSlackPostJSONImpl token method (Just body)

makeSlackPostJSONNoBody
  :: (MonadIO m)
  => Text
  -> Text
  -> m Aeson.Value
makeSlackPostJSONNoBody token method =
  makeSlackPostJSONImpl token method (Nothing @(Maybe ()))

makeSlackPostJSONImpl
  :: (MonadIO m, Aeson.ToJSON val)
  => Text
  -> Text
  -> Maybe val
  -> m Aeson.Value
makeSlackPostJSONImpl auth method mBody = do
  req <- liftIO $ HTTP.parseRequest $ "POST " <> "https://slack.com/api/" <> T.unpack method
  resp
    <- fmap HTTP.responseBody
     . HTTP.httpJSON
     . HTTP.addRequestHeader "Authorization" ("Bearer " <> T.encodeUtf8 auth)
     . maybe id HTTP.setRequestBodyJSON mBody
     $ req
  case resp ^? key "ok"  . _Bool of
    Just True  -> pure resp
    Just False -> throwIO $ userError $ T.unpack $ resp ^. key "error" . _String
    Nothing    -> throwIO $ userError "Couldn't parse key 'ok' from response"


module Slacker.Web
  ( -- * Message formatting
    MessageContent(..)
  , blocks_
  , blocks
  , blocksJSON
  , text
    -- * Response URL
  , MessagePayload(..)
  , respondMessage
  , response
  , ephemeral
    -- * chat.postMessage
  , PostMessagePayload(..)
  , postMessage
  , toChannel
  , toThread
    -- * General POST helpers
  , makeSlackPostJSON
  , makeSlackPostJSONNoBody
  ) where

import           Control.Lens hiding ((??))
import           Control.Monad (void)
import           Control.Monad.IO.Unlift (MonadIO, liftIO)
import qualified Data.Aeson as Aeson
import qualified Data.Aeson.Types as Aeson
import           Data.Aeson.Lens
import           Data.Maybe (catMaybes)
import           Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import           GHC.Generics (Generic)
import qualified Network.HTTP.Client as HTTP
import qualified Network.HTTP.Simple as HTTP
import           UnliftIO.Exception

import           Slacker.Blocks (Blocks)
import           Slacker.Config (SlackConfig(..))

data MessagePayload
  = MessagePayload
  { mpEphemeral :: !Bool
  , mpContent   :: !MessageContent
  } deriving stock (Generic, Show, Eq, Ord)

instance Aeson.ToJSON MessagePayload where
  toJSON MessagePayload{..}
    = Aeson.object
    $ catMaybes
    [ if mpEphemeral
        then Just ("response_type" Aeson..= Aeson.String "ephemeral")
        else Nothing
    ] ++ messageContentFields mpContent

-- | Turn formatted content into a response payload.
response :: MessageContent -> MessagePayload
response = MessagePayload False

-- | Turn formatted content into an ephemeral response.
-- https://api.slack.com/interactivity/handling#publishing_ephemeral_response
ephemeral :: MessageContent -> MessagePayload
ephemeral = MessagePayload True

data PostMessagePayload
  = PostMessagePayload
  { pmpChannel  :: !Text
  , pmpThreadTs :: !(Maybe Text)
  , pmpContent  :: !MessageContent
  } deriving stock (Generic, Show, Eq, Ord)

instance Aeson.ToJSON PostMessagePayload where
  toJSON PostMessagePayload{..}
    = Aeson.object
    $ catMaybes
    [ Just $ "channel" Aeson..= pmpChannel
    , fmap ("thread_ts" Aeson..=) pmpThreadTs
    ] ++ messageContentFields pmpContent

-- | Build a postMessage payload for a channel message.
toChannel :: Text -> MessageContent -> PostMessagePayload
toChannel cid = PostMessagePayload cid Nothing

-- | Build a postMessage payload for a thread reply.
toThread :: Text -> Text -> MessageContent -> PostMessagePayload
toThread cid ts = PostMessagePayload cid (Just ts)

data MessageContent
  = MessageBlocks !(Maybe Text) !Blocks
  | MessageText !Text
  | MessageBlocksJSON !Aeson.Value
-- ^ An escape hatch if you want to use something like `aesonQQ` to write
-- literal JSON, like that generated by the Block Kit Builder:
-- https://app.slack.com/block-kit-builder/
  deriving stock (Show, Eq, Ord)

messageContentFields :: MessageContent -> [Aeson.Pair]
messageContentFields mc =
  case mc of
    MessageBlocks mText neBlocks -> catMaybes
      [ Just $ "blocks" Aeson..= neBlocks
      , fmap ("text" Aeson..=) mText
      ]
    MessageText txt ->
      [ "text" Aeson..= txt ]
    MessageBlocksJSON val ->
      [ "blocks" Aeson..= val ]

-- | Construct a message as blocks with fallback text
blocks :: Text -> Blocks -> MessageContent
blocks txt = MessageBlocks (Just txt)

-- | Construct a message as blocks only
blocks_ :: Blocks -> MessageContent
blocks_ = MessageBlocks Nothing

-- | An escape hatch if you want to use something like `aesonQQ` to write
-- literal JSON, like that generated by the Block Kit Builder:
-- https://app.slack.com/block-kit-builder/
blocksJSON :: Aeson.Value -> MessageContent
blocksJSON = MessageBlocksJSON

-- | Construct a text message
text :: Text -> MessageContent
text = MessageText

-- | Respond to a user via an action's response URL.
-- https://api.slack.com/interactivity/handling#message_responses
respondMessage
  :: MonadIO m
  => Text
  -- ^ Response URL from Slack.
  -> MessagePayload
  -> m ()
respondMessage url body = do
  req <- liftIO $ HTTP.parseRequest $ "POST " <> T.unpack url
  void . HTTP.httpLBS . HTTP.setRequestBodyJSON body $ req

-- | Use the `chat.postMessage` method to send a message to a particular channel.
postMessage
  :: MonadIO m
  => SlackConfig
  -> PostMessagePayload
  -> m ()
postMessage cfg payload =
  void $
    makeSlackPostJSON
      (slackApiToken cfg)
      "chat.postMessage"
      payload

makeSlackPostJSON
  :: (MonadIO m, Aeson.ToJSON val)
  => Text
  -> Text
  -> val
  -> m Aeson.Value
makeSlackPostJSON token method body =
  makeSlackPostJSONImpl token method (Just body)

makeSlackPostJSONNoBody
  :: (MonadIO m)
  => Text
  -> Text
  -> m Aeson.Value
makeSlackPostJSONNoBody token method =
  makeSlackPostJSONImpl token method (Nothing @(Maybe ()))

makeSlackPostJSONImpl
  :: (MonadIO m, Aeson.ToJSON val)
  => Text
  -> Text
  -> Maybe val
  -> m Aeson.Value
makeSlackPostJSONImpl auth method mBody = do
  req <- liftIO $ HTTP.parseRequest $ "POST " <> "https://slack.com/api/" <> T.unpack method
  resp
    <- fmap HTTP.responseBody
     . HTTP.httpJSON
     . HTTP.addRequestHeader "Authorization" ("Bearer " <> T.encodeUtf8 auth)
     . maybe id HTTP.setRequestBodyJSON mBody
     $ req
  case resp ^? key "ok"  . _Bool of
    Just True  -> pure resp
    Just False -> throwIO $ userError $ T.unpack $ resp ^. key "error" . _String
    Nothing    -> throwIO $ userError "Couldn't parse key 'ok' from response"

